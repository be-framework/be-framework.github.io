---
layout: docs-ja
title: "10. 背後にある哲学"
category: Manual
permalink: /manuals/1.0/ja/10-philosophy-behind.html
---

# 背後にある哲学

Beフレームワークが実際にどのように動作するかを理解したので、それを可能にする深い哲学的原理を探求しましょう。

## 無為: 無行動の技術

**無為**は「行動なき行動」という古代中国の原理です—強制して行うよりも、存在することによって達成する。

Beフレームワークでは、これは次のように現れます：

```php
// これではない（命令的な実行）：
$validator->validate($email);
$formatter->format($name);
$user->save();

// これ（自然な成長）：
$user = $becoming(new UserInput($email, $name));
// ユーザーは単純にあるべき姿になる
```

オブジェクトは何かを「する」のではありません—自然な変容を通して彼らがあるものに**なります**。水が丘を下って流れるように、道は外部の命令からではなく、物事の性質から生まれます。

## 内在と超越: 存在の舞踊

これらの用語は哲学から来ており、存在がどのように意味のある存在になるかを記述します：

**内在**: 何かが既にあるもの—その固有の性質、アイデンティティ、本質。変化を通して持続する「自己」。

**超越**: 自己を超えて来るもの—文脈、能力、世界によって提供される意味。

```php
// コードでの哲学的例：
final class Greeting
{
    public function __construct(
        #[Input] string $name,                // 内在: あなたが誰であるか
        #[Inject] CultureService $culture     // 超越: 世界がどのように挨拶するか
    ) {
        $this->message = $culture->formatGreeting($name);  // 新しい存在が生まれる
    }
}
```

これは人間がどのように彼らがなるものになるかを映し出しています—内部の特性だけでなく、他者、文化、そして自分を超えた世界との出会いを通して。

## BE = Be, Everything

**BE**はこの原理の普遍的な範囲を表します：

- **Be**: 行動ではなく存在に焦点を当てる
- **Everything**: この原理はすべてのプログラミングドメインに適用される

処理するものが何であれ：
- データベースレコード → ドメインオブジェクト
- HTTPリクエスト → APIレスポンス
- ユーザー入力 → 検証されたコマンド
- 生データ → ビジネス洞察

パターンは同じです：**内在 + 超越 → 新しい内在**

## 存在論的プログラミング

**存在論**は存在の哲学的研究です—何かが「存在する」とはどういう意味かです。

存在論的プログラミングは「何が起こるべきか？」ではなく**「何が存在できるか？」**と問います。

```php
// 従来型：「このメールをどのように検証すべきか？」
if ($email->isValid()) {
    $user = new User($email);
    $user->save();
}

// 存在論的：「メールが検証と出会うとき何が存在するか？」
#[Be(ValidatedUser::class)]
final class EmailInput { /* ... */ }

final class ValidatedUser { /* ... */ }  // これは単純に存在するかしないか
```

可能な存在形態を宣言することで設計し、オブジェクトがそれらの形態に自然になることを許します。

## 主客一体

従来のプログラミングでは、常にオブジェクトを指揮する「コントローラー」があります。Beフレームワークでは、**オブジェクトは自身の主体**です—自身の変容を決定します。

```php
// オブジェクトが自身の運命を決める
public readonly SuccessfulPayment|FailedPayment $being;

public function __construct(/* ... */) {
    $this->being = $this->isValid 
        ? new SuccessfulPayment(/* ... */)
        : new FailedPayment(/* ... */);  // 自己決定
}
```

外部のオーケストレーターがオブジェクトに何になるかを命令することはありません。変容は、オブジェクト自身の性質が世界の能力と出会うことから生まれます。

## 時間的存在

Beフレームワークのオブジェクトは**時間の中に**存在します—過去の記憶（内在）と潜在的な未来の知識（ユニオン型を持つ存在プロパティ）を持ちます。

```php
final class UserProfile
{
    // 過去の記憶
    #[Input] string $originalEmail;
    
    // 現在の存在
    public readonly string $displayName;
    
    // 潜在的な未来
    public readonly ActiveUser|SuspendedUser $being;
}
```

これは**時間的認識**を作り出します—オブジェクトは変容の流れにおける自身の位置を理解します。

## 自然法の美しさ

物理学が異なる力の下で物質がどのように自然に変容するかを記述するように、Beフレームワークはコンストラクタ注入を通してデータがどのように自然に変容するかを記述します。

法則は単純です：
1. **不変の存在**: 各段階は完全で不変です
2. **コンストラクタ変容**: すべての変容は成長の瞬間に起こります
3. **自己決定**: オブジェクトは自身の性質に基づいて自身の運命を選択します
4. **透明な状態**: すべてが公開され読み取り可能です

これらの単純な法則は、複雑で自然な変容の無限の可能性を作り出します—単純な物理法則が宇宙の無限の複雑さを作り出すように。

---

*「Beフレームワークは単にコードを書く方法ではありません—デジタル領域における存在、変容、そして成長の自然な流れについて考える方法です。」*

## パラダイムシフト

この哲学を理解することで、プログラミングへのアプローチが変わります：

- オブジェクトを**命令する**から → 成長のための**条件を作る**へ
- 状態を**管理する**から → 自然な変容を**可能にする**へ
- フローを**制御する**から → 可能性を**宣言する**へ
- **実行**から → **存在**へ

これが**存在論的プログラミング**の本質です—存在と変容の自然な原理と一致するプログラミングです。